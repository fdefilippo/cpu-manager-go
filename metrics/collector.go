/*
 * Copyright (C) 2026 Francesco Defilippo
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
// metrics/collector.go
package metrics

import (
    "bufio"
    "fmt"
//    "io"
    "os"
    "path/filepath"
    "strconv"
    "strings"
    "sync"
    "time"

    "github.com/fdefilippo/cpu-manager-go/config"
    "github.com/fdefilippo/cpu-manager-go/logging"
    "github.com/shirou/gopsutil/v3/cpu"
    "github.com/shirou/gopsutil/v3/mem"
    "github.com/shirou/gopsutil/v3/process"
)

// UserMetrics contiene le metriche per un singolo utente.
type UserMetrics struct {
    UID          int
    Username     string
    CPUUsage     float64  // Percentuale CPU
    MemoryUsage  uint64   // Memoria in bytes (VmRSS)
    ProcessCount int      // Numero di processi
}

// Collector raccoglie metriche di sistema.
type Collector struct {
    cfg        *config.Config
    logger     *logging.Logger
    mu         sync.RWMutex

    // Cache per le metriche
    cache            map[string]interface{}
    cacheTimestamps  map[string]time.Time
    cacheMutex       sync.RWMutex

    // Stato precedente per calcolo delta CPU
    prevCPUStats cpu.TimesStat
    prevCPUTime  time.Time
}

// NewCollector crea un nuovo collettore di metriche.
func NewCollector(cfg *config.Config) (*Collector, error) {
    logger := logging.GetLogger()

    collector := &Collector{
        cfg:             cfg,
        logger:          logger,
        cache:           make(map[string]interface{}),
        cacheTimestamps: make(map[string]time.Time),
        prevCPUTime:     time.Now(),
    }

    // Inizializza le statistiche CPU precedenti
    if stats, err := cpu.Times(false); err == nil && len(stats) > 0 {
        collector.prevCPUStats = stats[0]
    }

    logger.Info("Metrics collector initialized")
    return collector, nil
}

// GetTotalCores restituisce il numero totale di core CPU.
func (c *Collector) GetTotalCores() int {
    cacheKey := "total_cores"
    if val, valid := c.getFromCache(cacheKey, 3600*time.Second); valid { // Cache lunga per questa metrica
        return val.(int)
    }

    cores, err := cpu.Counts(true)
    if err != nil {
        c.logger.Warn("Failed to get CPU core count, using fallback", "error", err)
        // Fallback: leggi da /proc/cpuinfo
        cores = c.getTotalCoresFallback()
    }

    c.setInCache(cacheKey, cores)
    return cores
}

// getTotalCoresFallback è un fallback per ottenere il numero di core.
func (c *Collector) getTotalCoresFallback() int {
    file, err := os.Open("/proc/cpuinfo")
    if err != nil {
        c.logger.Error("Failed to open /proc/cpuinfo", "error", err)
        return 1
    }
    defer file.Close()

    cores := 0
    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        line := scanner.Text()
        if strings.HasPrefix(line, "processor") {
            cores++
        }
    }

    if cores == 0 {
        cores = 1
    }

    return cores
}

// GetTotalCPUUsage restituisce l'uso totale della CPU in percentuale.
func (c *Collector) GetTotalCPUUsage() float64 {
    cacheKey := "total_cpu_usage"
    if val, valid := c.getFromCache(cacheKey, time.Duration(c.cfg.MetricsCacheTTL)*time.Second); valid {
        return val.(float64)
    }

    // Usa gopsutil per ottenere l'uso CPU
    percentages, err := cpu.Percent(time.Second, false)
    if err != nil || len(percentages) == 0 {
        c.logger.Warn("Failed to get CPU usage via gopsutil, using fallback", "error", err)
        // Fallback al metodo manuale
        return c.getTotalCPUUsageFallback()
    }

    usage := percentages[0]
    c.setInCache(cacheKey, usage)
    return usage
}

// getTotalCPUUsageFallback calcola l'uso CPU manualmente da /proc/stat.
func (c *Collector) getTotalCPUUsageFallback() float64 {
    file, err := os.Open("/proc/stat")
    if err != nil {
        c.logger.Error("Failed to open /proc/stat", "error", err)
        return 0.0
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    if !scanner.Scan() {
        return 0.0
    }

    line := scanner.Text()
    if !strings.HasPrefix(line, "cpu ") {
        return 0.0
    }

    // Parse della linea CPU
    fields := strings.Fields(line)
    if len(fields) < 8 {
        return 0.0
    }

    // Calcola i tempi totali
    user, _ := strconv.ParseUint(fields[1], 10, 64)
    nice, _ := strconv.ParseUint(fields[2], 10, 64)
    system, _ := strconv.ParseUint(fields[3], 10, 64)
    idle, _ := strconv.ParseUint(fields[4], 10, 64)
    iowait, _ := strconv.ParseUint(fields[5], 10, 64)
    irq, _ := strconv.ParseUint(fields[6], 10, 64)
    softirq, _ := strconv.ParseUint(fields[7], 10, 64)
    steal := uint64(0)
    if len(fields) > 8 {
        steal, _ = strconv.ParseUint(fields[8], 10, 64)
    }

    total := user + nice + system + idle + iowait + irq + softirq + steal

    c.mu.Lock()
    defer c.mu.Unlock()

    // Calcola la differenza dal precedente campione
    if c.prevCPUStats.User == 0 && c.prevCPUStats.System == 0 && c.prevCPUStats.Idle == 0 {
        // Primo campione, salva e ritorna 0
        c.prevCPUStats = cpu.TimesStat{
            User:   float64(user),
            Nice:   float64(nice),
            System: float64(system),
            Idle:   float64(idle),
            Iowait: float64(iowait),
            Irq:    float64(irq),
            Softirq: float64(softirq),
            Steal:  float64(steal),
        }
        c.prevCPUTime = time.Now()
        return 0.0
    }

    // Calcola delta
    totalDelta := total - (uint64(c.prevCPUStats.User) + uint64(c.prevCPUStats.Nice) +
                         uint64(c.prevCPUStats.System) + uint64(c.prevCPUStats.Idle) +
                         uint64(c.prevCPUStats.Iowait) + uint64(c.prevCPUStats.Irq) +
                         uint64(c.prevCPUStats.Softirq) + uint64(c.prevCPUStats.Steal))
    idleDelta := idle - uint64(c.prevCPUStats.Idle)

    // Aggiorna lo stato precedente
    c.prevCPUStats = cpu.TimesStat{
        User:   float64(user),
        Nice:   float64(nice),
        System: float64(system),
        Idle:   float64(idle),
        Iowait: float64(iowait),
        Irq:    float64(irq),
        Softirq: float64(softirq),
        Steal:  float64(steal),
    }

    if totalDelta == 0 {
        return 0.0
    }

    usage := 100.0 * float64(totalDelta-idleDelta) / float64(totalDelta)

    // Cache il risultato
    c.setInCache("total_cpu_usage", usage)

    return usage
}

// GetUserCPUUsage restituisce l'uso CPU per un utente specifico.
func (c *Collector) GetUserCPUUsage(uid int) float64 {
    if !c.isValidUserUID(uid) {
        return 0.0
    }

    cacheKey := fmt.Sprintf("cpu_usage_uid_%d", uid)
    if val, valid := c.getFromCache(cacheKey, time.Duration(c.cfg.MetricsCacheTTL)*time.Second); valid {
        return val.(float64)
    }

    var totalUsage float64

    // Metodo 1: Usa gopsutil/process
    processes, err := process.Processes()
    if err == nil {
        for _, p := range processes {
            // Ottieni l'UID del processo
            if uids, err := p.Uids(); err == nil && len(uids) > 0 {
                if int(uids[0]) == uid { // UID reale
                    if cpuPercent, err := p.CPUPercent(); err == nil {
                        totalUsage += cpuPercent
                    }
                }
            }
        }
    } else {
        // Fallback: usa ps command come nello script Bash
        totalUsage = c.getUserCPUUsageFallback(uid)
    }

    c.setInCache(cacheKey, totalUsage)
    return totalUsage
}

// getUserCPUUsageFallback usa ps per ottenere l'uso CPU (simile allo script Bash).
func (c *Collector) getUserCPUUsageFallback(uid int) float64 {
    // Costruisci il comando ps
    // cmd := fmt.Sprintf("ps -U %d -o pcpu=", uid)

    // Esegui il comando e parsa l'output
    // Nota: In produzione, useremmo os/exec invece di eseguire shell commands
    // Per ora implementiamo una versione semplificata
    return c.getUserCPUUsageFromProc(uid)
}

// getUserCPUUsageFromProc calcola l'uso CPU leggendo da /proc.
func (c *Collector) getUserCPUUsageFromProc(uid int) float64 {
    var totalUsage float64

    // Itera su tutte le directory in /proc
    procDir := "/proc"
    entries, err := os.ReadDir(procDir)
    if err != nil {
        c.logger.Warn("Failed to read /proc directory", "error", err)
        return 0.0
    }

    for _, entry := range entries {
        if !entry.IsDir() {
            continue
        }

        // Verifica se è una directory PID
        pid, err := strconv.Atoi(entry.Name())
        if err != nil {
            continue
        }

        // Leggi l'UID del processo
        statusFile := filepath.Join(procDir, entry.Name(), "status")
        procUID, err := c.getUIDFromStatusFile(statusFile)
        if err != nil || procUID != uid {
            continue
        }

        // Leggi l'uso CPU del processo
        cpuUsage, err := c.getProcessCPUUsage(pid)
        if err == nil {
            totalUsage += cpuUsage
        }
    }

    return totalUsage
}

// getUIDFromStatusFile legge l'UID da /proc/[pid]/status.
func (c *Collector) getUIDFromStatusFile(statusFile string) (int, error) {
    file, err := os.Open(statusFile)
    if err != nil {
        return 0, err
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        line := scanner.Text()
        if strings.HasPrefix(line, "Uid:") {
            fields := strings.Fields(line)
            if len(fields) >= 2 {
                uid, err := strconv.Atoi(fields[1])
                if err != nil {
                    return 0, err
                }
                return uid, nil
            }
        }
    }

    return 0, fmt.Errorf("UID not found")
}

// getProcessCPUUsage calcola l'uso CPU di un singolo processo.
func (c *Collector) getProcessCPUUsage(pid int) (float64, error) {
    statFile := fmt.Sprintf("/proc/%d/stat", pid)

    // Leggi il file stat del processo
    content, err := os.ReadFile(statFile)
    if err != nil {
        return 0.0, err
    }

    // Parse dei dati del processo per calcolare l'uso CPU
    // Il formato di /proc/[pid]/stat è complesso
    // Per una implementazione semplifica, leggiamo il tempo CPU
    stats := strings.Fields(string(content))
    if len(stats) < 15 {
        return 0.0, fmt.Errorf("invalid stat format for PID %d", pid)
    }

    // Tempo CPU speso in user mode (jiffies) - campo 13
    // Tempo CPU speso in kernel mode (jiffies) - campo 14
    utime, err1 := strconv.ParseUint(stats[13], 10, 64)
    stime, err2 := strconv.ParseUint(stats[14], 10, 64)

    if err1 != nil || err2 != nil {
        return 0.0, fmt.Errorf("failed to parse CPU times for PID %d", pid)
    }

    // Per calcolare la percentuale CPU, dovremmo:
    // 1. Salvare i valori precedenti
    // 2. Calcolare la differenza tra due letture
    // 3. Dividere per il tempo trascorso

    // Per ora, restituiamo una stima molto semplificata
    // In una implementazione completa, dovremmo implementare la cache
    // e il calcolo delle differenze

    // Stima semplificata: (utime + stime) in jiffies
    // 1 jiffy = tipicamente 10ms = 0.01s
    totalJiffies := float64(utime + stime)

    // Converti in secondi (assumendo 100 jiffies/secondo)
    cpuSeconds := totalJiffies / 100.0

    // Per ottenere una percentuale, dovremmo dividere per il tempo di esecuzione
    // del processo. Per semplicità, restituiamo un valore basso.
    // In produzione, implementeremmo la logica completa.

    return cpuSeconds * 0.1, nil // Stima molto approssimativa
}
// GetTotalUserCPUUsage restituisce l'uso CPU totale di tutti gli utenti non di sistema.
func (c *Collector) GetTotalUserCPUUsage() float64 {
    cacheKey := "total_user_cpu_usage"
    if val, valid := c.getFromCache(cacheKey, time.Duration(c.cfg.MetricsCacheTTL)*time.Second); valid {
        return val.(float64)
    }

    var totalUsage float64

    // Ottieni tutti gli utenti attivi
    activeUsers := c.GetActiveUsers()
    for _, uid := range activeUsers {
        totalUsage += c.GetUserCPUUsage(uid)
    }

    c.setInCache(cacheKey, totalUsage)
    return totalUsage
}

// GetActiveUsers restituisce la lista degli UID attivi (non di sistema).
func (c *Collector) GetActiveUsers() []int {
    cacheKey := "active_users"
    if val, valid := c.getFromCache(cacheKey, time.Duration(c.cfg.MetricsCacheTTL)*time.Second); valid {
        return val.([]int)
    }

    uidMap := make(map[int]bool)

    // Metodo 1: Usa gopsutil
    processes, err := process.Processes()
    if err == nil {
        for _, p := range processes {
            if uids, err := p.Uids(); err == nil && len(uids) > 0 {
                uid := int(uids[0])
                if c.isValidUserUID(uid) {
                    uidMap[uid] = true
                }
            }
        }
    } else {
        // Fallback: legge da /proc
        uidMap = c.getActiveUsersFromProc()
    }

    // Converti la mappa in slice
    users := make([]int, 0, len(uidMap))
    for uid := range uidMap {
        users = append(users, uid)
    }

    c.setInCache(cacheKey, users)
    return users
}

// getActiveUsersFromProc legge gli utenti attivi da /proc.
func (c *Collector) getActiveUsersFromProc() map[int]bool {
    uidMap := make(map[int]bool)

    procDir := "/proc"
    entries, err := os.ReadDir(procDir)
    if err != nil {
        c.logger.Warn("Failed to read /proc directory", "error", err)
        return uidMap
    }

    for _, entry := range entries {
        if !entry.IsDir() {
            continue
        }

        // Verifica se è una directory PID
        if _, err := strconv.Atoi(entry.Name()); err != nil {
            continue
        }

        // Leggi l'UID
        statusFile := filepath.Join(procDir, entry.Name(), "status")
        if uid, err := c.getUIDFromStatusFile(statusFile); err == nil {
            if c.isValidUserUID(uid) {
                uidMap[uid] = true
            }
        }
    }

    return uidMap
}

// GetMemoryUsage restituisce l'uso della memoria in MB.
func (c *Collector) GetMemoryUsage() float64 {
    cacheKey := "memory_usage"
    if val, valid := c.getFromCache(cacheKey, time.Duration(c.cfg.MetricsCacheTTL)*time.Second); valid {
        return val.(float64)
    }

    vm, err := mem.VirtualMemory()
    if err != nil {
        c.logger.Warn("Failed to get memory info via gopsutil, using fallback", "error", err)
        return c.getMemoryUsageFallback()
    }

    // Converti da byte a MB
    usageMB := float64(vm.Used) / 1024 / 1024
    c.setInCache(cacheKey, usageMB)
    return usageMB
}

// getMemoryUsageFallback legge l'uso memoria da /proc/meminfo.
func (c *Collector) getMemoryUsageFallback() float64 {
    file, err := os.Open("/proc/meminfo")
    if err != nil {
        c.logger.Error("Failed to open /proc/meminfo", "error", err)
        return 0.0
    }
    defer file.Close()

    var memTotal, memAvailable float64
    scanner := bufio.NewScanner(file)

    for scanner.Scan() {
        line := scanner.Text()
        fields := strings.Fields(line)
        if len(fields) < 2 {
            continue
        }

        switch fields[0] {
        case "MemTotal:":
            memTotal, _ = strconv.ParseFloat(fields[1], 64)
        case "MemAvailable:":
            memAvailable, _ = strconv.ParseFloat(fields[1], 64)
        }

        //if memTotal > 0 && memAvailable > 0 {
        //    break
        //}
    }

    if memTotal == 0 {
        return 0.0
    }

    // Se memAvailable non è stato trovato, usa MemFree come fallback
    if memAvailable == 0 {
        // Dovremmo rileggere il file per MemFree, ma per semplicità usiamo 0
        memAvailable = 0
    }

    // MemTotal e MemAvailable sono in KB, converti a MB
    usageMB := (memTotal - memAvailable) / 1024
    return usageMB
}

// IsSystemUnderLoad determina se il sistema è sotto carico.
func (c *Collector) IsSystemUnderLoad() bool {
    cacheKey := "system_under_load"
    if val, valid := c.getFromCache(cacheKey, 10*time.Second); valid { // Cache breve
        return val.(bool)
    }

    // Calcola load average
    load, cores, err := c.getLoadAverage()
    if err != nil {
        c.logger.Warn("Failed to get load average", "error", err)
        return false
    }

    // Sistema è sotto carico se load > 0.7 * cores
    underLoad := load > float64(cores)*0.7

    c.setInCache(cacheKey, underLoad)
    return underLoad
}

// getLoadAverage restituisce load average e numero di core.
func (c *Collector) getLoadAverage() (float64, int, error) {
    data, err := os.ReadFile("/proc/loadavg")
    if err != nil {
        return 0.0, 0, err
    }

    fields := strings.Fields(string(data))
    if len(fields) == 0 {
        return 0.0, 0, fmt.Errorf("invalid loadavg format")
    }

    load1, err := strconv.ParseFloat(fields[0], 64)
    if err != nil {
        return 0.0, 0, err
    }

    cores := c.GetTotalCores()
    return load1, cores, nil
}

// isValidUserUID verifica se un UID è un utente non di sistema.
func (c *Collector) isValidUserUID(uid int) bool {
    return uid >= c.cfg.SystemUIDMin && uid <= c.cfg.SystemUIDMax
}

// getFromCache recupera un valore dalla cache se non è scaduto.
func (c *Collector) getFromCache(key string, ttl time.Duration) (interface{}, bool) {
    c.cacheMutex.RLock()
    defer c.cacheMutex.RUnlock()

    val, exists := c.cache[key]
    if !exists {
        return nil, false
    }

    timestamp, timestampExists := c.cacheTimestamps[key]
    if !timestampExists {
        return nil, false
    }

    if time.Since(timestamp) > ttl {
        return nil, false
    }

    return val, true
}

// setInCache memorizza un valore nella cache.
func (c *Collector) setInCache(key string, value interface{}) {
    c.cacheMutex.Lock()
    defer c.cacheMutex.Unlock()

    c.cache[key] = value
    c.cacheTimestamps[key] = time.Now()

    // Pulizia periodica della cache
    if len(c.cache) > 100 {
        go c.cleanupCache()
    }
}

// cleanupCache rimuove le voci scadute dalla cache.
func (c *Collector) cleanupCache() {
    c.cacheMutex.Lock()
    defer c.cacheMutex.Unlock()

    now := time.Now()
    for key, timestamp := range c.cacheTimestamps {
        if now.Sub(timestamp) > 5*time.Minute {
            delete(c.cache, key)
            delete(c.cacheTimestamps, key)
        }
    }
}

// ClearCache svuota la cache.
func (c *Collector) ClearCache() {
    c.cacheMutex.Lock()
    defer c.cacheMutex.Unlock()

    c.cache = make(map[string]interface{})
    c.cacheTimestamps = make(map[string]time.Time)
}

// GetDetailedMetrics restituisce metriche dettagliate per debugging.
func (c *Collector) GetDetailedMetrics() map[string]interface{} {
    metrics := make(map[string]interface{})

    metrics["total_cores"] = c.GetTotalCores()
    metrics["total_cpu_usage"] = c.GetTotalCPUUsage()
    metrics["total_user_cpu_usage"] = c.GetTotalUserCPUUsage()
    metrics["memory_usage_mb"] = c.GetMemoryUsage()
    metrics["system_under_load"] = c.IsSystemUnderLoad()

    activeUsers := c.GetActiveUsers()
    metrics["active_users_count"] = len(activeUsers)

    // Uso CPU per utente
    userCPU := make(map[int]float64)
    for _, uid := range activeUsers {
        userCPU[uid] = c.GetUserCPUUsage(uid)
    }
    metrics["user_cpu_usage"] = userCPU

    // Informazioni sulla cache
    c.cacheMutex.RLock()
    metrics["cache_size"] = len(c.cache)
    c.cacheMutex.RUnlock()

    return metrics
}

// GetSystemLoad restituisce il load average di 1 minuto.
func (c *Collector) GetSystemLoad() (float64, error) {
    data, err := os.ReadFile("/proc/loadavg")
    if err != nil {
        return 0.0, err
    }

    fields := strings.Fields(string(data))
    if len(fields) == 0 {
        return 0.0, fmt.Errorf("invalid loadavg format")
    }

    load1, err := strconv.ParseFloat(fields[0], 64)
    if err != nil {
        return 0.0, err
    }

    return load1, nil
}

// GetAllUserMetrics restituisce le metriche (CPU, memoria, processi) per tutti gli utenti attivi.
// Questa funzione scansiona /proc una sola volta per efficienza.
func (c *Collector) GetAllUserMetrics() map[int]*UserMetrics {
    cacheKey := "all_user_metrics"
    if val, valid := c.getFromCache(cacheKey, time.Duration(c.cfg.MetricsCacheTTL)*time.Second); valid {
        if metrics, ok := val.(map[int]*UserMetrics); ok {
            return metrics
        }
    }

    userMetrics := make(map[int]*UserMetrics)
    procDir := "/proc"

    entries, err := os.ReadDir(procDir)
    if err != nil {
        c.logger.Warn("Failed to read /proc directory for user metrics", "error", err)
        return userMetrics
    }

    // Mappa temporanea per accumulare i dati per UID
    type userData struct {
        cpuUsage     float64
        memoryUsage  uint64
        processCount int
    }
    tempData := make(map[int]*userData)

    for _, entry := range entries {
        if !entry.IsDir() {
            continue
        }

        pid, err := strconv.Atoi(entry.Name())
        if err != nil {
            continue
        }

        // Leggi UID del processo
        statusFile := filepath.Join(procDir, entry.Name(), "status")
        uid, err := c.getUIDFromStatusFile(statusFile)
        if err != nil || !c.isValidUserUID(uid) {
            continue
        }

        // Inizializza struttura se non esiste
        if tempData[uid] == nil {
            tempData[uid] = &userData{}
        }

        // Conta il processo
        tempData[uid].processCount++

        // Leggi uso CPU
        cpuUsage := c.getProcessCPUUsageSimple(pid)
        tempData[uid].cpuUsage += cpuUsage

        // Leggi uso memoria (VmRSS in bytes)
        memoryUsage := c.getProcessMemoryUsage(pid)
        tempData[uid].memoryUsage += memoryUsage
    }

    // Converte in UserMetrics con username
    for uid, data := range tempData {
        userMetrics[uid] = &UserMetrics{
            UID:          uid,
            Username:     c.getUsernameFromUID(uid),
            CPUUsage:     data.cpuUsage,
            MemoryUsage:  data.memoryUsage,
            ProcessCount: data.processCount,
        }
    }

    c.setInCache(cacheKey, userMetrics)
    return userMetrics
}

// GetUserMemoryUsage restituisce la memoria totale usata da un utente in bytes.
func (c *Collector) GetUserMemoryUsage(uid int) uint64 {
    if !c.isValidUserUID(uid) {
        return 0
    }

    cacheKey := fmt.Sprintf("memory_usage_uid_%d", uid)
    if val, valid := c.getFromCache(cacheKey, time.Duration(c.cfg.MetricsCacheTTL)*time.Second); valid {
        return val.(uint64)
    }

    var totalMemory uint64

    procDir := "/proc"
    entries, err := os.ReadDir(procDir)
    if err != nil {
        c.logger.Warn("Failed to read /proc for memory stats", "error", err)
        return 0
    }

    for _, entry := range entries {
        if !entry.IsDir() {
            continue
        }

        pid, err := strconv.Atoi(entry.Name())
        if err != nil {
            continue
        }

        statusFile := filepath.Join(procDir, entry.Name(), "status")
        procUID, err := c.getUIDFromStatusFile(statusFile)
        if err != nil || procUID != uid {
            continue
        }

        memoryUsage := c.getProcessMemoryUsage(pid)
        totalMemory += memoryUsage
    }

    c.setInCache(cacheKey, totalMemory)
    return totalMemory
}

// getProcessMemoryUsage restituisce la memoria RSS di un processo in bytes.
// Legge VmRSS da /proc/[pid]/status.
func (c *Collector) getProcessMemoryUsage(pid int) uint64 {
    statusFile := fmt.Sprintf("/proc/%d/status", pid)
    data, err := os.ReadFile(statusFile)
    if err != nil {
        return 0
    }

    lines := strings.Split(string(data), "\n")
    for _, line := range lines {
        if strings.HasPrefix(line, "VmRSS:") {
            fields := strings.Fields(line)
            if len(fields) >= 2 {
                // VmRSS è in kB, converti in bytes
                kb, err := strconv.ParseUint(fields[1], 10, 64)
                if err != nil {
                    return 0
                }
                return kb * 1024
            }
        }
    }

    return 0
}

// getProcessCPUUsageSimple calcola l'uso CPU di un processo usando gopsutil se disponibile.
func (c *Collector) getProcessCPUUsageSimple(pid int) float64 {
    proc, err := process.NewProcess(int32(pid))
    if err != nil {
        return 0
    }

    cpuPercent, err := proc.CPUPercent()
    if err != nil {
        return 0
    }

    return cpuPercent
}

// getUsernameFromUID converte un UID in username leggendo /etc/passwd.
func (c *Collector) getUsernameFromUID(uid int) string {
    file, err := os.Open("/etc/passwd")
    if err != nil {
        return strconv.Itoa(uid)
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        line := scanner.Text()
        fields := strings.Split(line, ":")
        if len(fields) >= 3 {
            if fields[2] == strconv.Itoa(uid) {
                return fields[0]
            }
        }
    }

    return strconv.Itoa(uid)
}

// GetUserProcessCount restituisce il numero di processi di un utente.
func (c *Collector) GetUserProcessCount(uid int) int {
    if !c.isValidUserUID(uid) {
        return 0
    }

    cacheKey := fmt.Sprintf("process_count_uid_%d", uid)
    if val, valid := c.getFromCache(cacheKey, time.Duration(c.cfg.MetricsCacheTTL)*time.Second); valid {
        return val.(int)
    }

    count := 0
    procDir := "/proc"

    entries, err := os.ReadDir(procDir)
    if err != nil {
        return 0
    }

    for _, entry := range entries {
        if !entry.IsDir() {
            continue
        }

        _, err := strconv.Atoi(entry.Name())
        if err != nil {
            continue
        }

        statusFile := filepath.Join(procDir, entry.Name(), "status")
        procUID, err := c.getUIDFromStatusFile(statusFile)
        if err == nil && procUID == uid {
            count++
        }
    }

    c.setInCache(cacheKey, count)
    return count
}
